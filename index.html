<html>
<head>
    <title>Bugatti Veyron - Auto Show</title>
    <link rel="shortcut icon" href="img/favicon.png">
    <link rel="stylesheet" type="text/css" href="bower_components/colpick-jQuery-Color-Picker/css/colpick.css">
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <script src="bower_components/threejs/build/three.js"></script>
    <script src="bower_components/jquery/dist/jquery.min.js"></script>
    <script src="bower_components/colpick-jQuery-Color-Picker/js/colpick.js"></script>

    <script src="bower_components/threejs/examples/js/loaders/BinaryLoader.js"></script>
    <script src="bower_components/threejs/examples/js/loaders/TGALoader.js"></script>

    <script src="bower_components/stats.js/build/stats.min.js"></script>
    <script src="bower_components/threejs/examples/js/libs/dat.gui.min.js"></script>

    <script src="bower_components/threejs/examples/js/shaders/CopyShader.js"></script>

    <script src="bower_components/threejs/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="bower_components/threejs/examples/js/postprocessing/RenderPass.js"></script>
    <script src="bower_components/threejs/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="bower_components/threejs/examples/js/postprocessing/MaskPass.js"></script>

    <script src="bower_components/threejs/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <script type="text/x-glsl" id="vertex-lambert">
        uniform vec3 rho;
        uniform vec3 ambient;
        uniform vec3 lightPosition[2];
        uniform vec3 materialColor;
        uniform vec3 lightPower;

        varying vec3 vColor;
        varying vec3 outRadiance;

        const float PI = 3.14159265359;

        void main() {
            vColor = materialColor;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

            outRadiance = vec3(0.0, 0.0, 0.0);

            vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
            vec3 vNormal = normalMatrix * normal;

            for (int i = 0; i < 3; i++) {
                vec4 lPosition = viewMatrix * vec4(lightPosition[i], 1.0);
                vec3 lVector = lPosition.xyz - modelViewPosition.xyz;
                vec3 beta = lightPower / (4.0  * PI * length(lVector));
                lVector = normalize(lVector);
                float dotProduct = dot(vNormal, lVector);
                float pointLightWeighting = max(dotProduct, 0.0);
                outRadiance = outRadiance + (beta * pointLightWeighting * rho / PI);
            }

            outRadiance += ambient;
		}
    </script>
    <script type="text/x-glsl" id="fragment-default">
        varying vec3 vColor;
        varying vec3 outRadiance;

        void main() {
            gl_FragColor = vec4(outRadiance, 1.0);
        }
    </script>
    <script type="text/x-glsl" id="vertex-phong">
        // http://www.mathematik.uni-marburg.de/~thormae/lectures/graphics1/code/WebGLShaderLightMat/ShaderLightMat.html
        uniform vec3 lightPosition[2];
        uniform vec3 ambient;
        varying vec3 outRadiance;

        const vec3 diffuseColor = vec3(1.0, 1.0, 1.0);
        const vec3 specColor = vec3(1.0, 1.0, 1.0);

        void main(){
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          vec3 vNormal = normalMatrix * normal;
          outRadiance = vec3(0.0, 0.0, 0.0);

          for (int i = 0; i < 3; i++) {
            vec4 lPosition = viewMatrix * vec4(lightPosition[i], 1.0);
            vec3 vertPos = vec3(lPosition) / lPosition.w;
            vec3 lightDir = normalize(lightPosition[i] - vertPos);
            vec3 reflectDir = reflect(-lightDir, vNormal);
            vec3 viewDir = normalize(-vertPos);

            float lambertian = max(dot(lightDir,normal), 0.0);
            float specular = 0.0;

            if(lambertian > 0.0) {
                float specAngle = max(dot(reflectDir, viewDir), 0.0);
                specular = pow(specAngle, 4.0);

                // according to the rendering equation we would need to multiply
                // with the the "lambertian", but this has little visual effect
                specular *= lambertian;
            }

            outRadiance = outRadiance + (lambertian * diffuseColor + specular * specColor);
          }

          outRadiance += ambient;
        }
    </script>
    <script type="text/x-glsl" id="vertex-default-texture">
        varying vec2 vUv;

        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script type="text/x-glsl" id="fragment-vignette">
        uniform float offset;
        uniform float darkness;
        uniform sampler2D tDiffuse;

        varying vec2 vUv;

        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            vec2 uv = (vUv - vec2(0.5) ) * vec2(offset);
            gl_FragColor = vec4(mix(texel.rgb, vec3(1.0 - darkness), dot(uv, uv)), texel.a);
        }
    </script>
    <div id="panel">
        <div id="logo">
            <img src="img/bugatti-logo.png" alt=""/>
        </div>
    </div>
    <div id="controls">
        <button class="btn icon-color"></button>
    </div>
    <script src="js/main.js"></script>
</body>
</html>
